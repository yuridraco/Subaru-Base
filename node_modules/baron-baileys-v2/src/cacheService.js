const fs = require('fs');
const path = require('path');
const moment = require('moment-timezone');

const CACHE_DIR = path.join(__dirname, './cache/group_metadata');
if (!fs.existsSync(CACHE_DIR)) fs.mkdirSync(CACHE_DIR, { recursive: true });

class CacheService {
constructor() {
this.groupMetaMap = new Map();
}

_getPath(groupId) {
return path.join(CACHE_DIR, `${groupId}.json`);
}

saveGroupMetadata(groupId, data) {
try {
const filePath = this._getPath(groupId);
const dataToSave = {
...data,
lastUpdated: moment().toISOString()
};
fs.writeFileSync(filePath, JSON.stringify(dataToSave, null, 2));
this.groupMetaMap.set(groupId, dataToSave);
} catch (err) {
console.error(`❌ Erro ao salvar metadata em cache (${groupId}):`, err);
}
}

getGroupMetadata(groupId) {
const filePath = this._getPath(groupId);

try {
if (fs.existsSync(filePath)) {
const data = JSON.parse(fs.readFileSync(filePath, 'utf8'));
this.groupMetaMap.set(groupId, data);
return data;
}
} catch (err) {
console.warn(`⚠️ Erro lendo metadata JSON (${groupId}):`, err);
}
if (this.groupMetaMap.has(groupId)) {
return this.groupMetaMap.get(groupId);
}

return null;
}

async updateFromAPI(groupId, conn) {
try {
const meta = await conn.groupMetadata(groupId);
this.saveGroupMetadata(groupId, meta);
return meta;
} catch (err) {
console.error(`❌ Erro ao buscar metadata via API (${groupId}):`, err);
return null;
}
}

clearCache(groupId) {
const filePath = this._getPath(groupId);
if (fs.existsSync(filePath)) fs.unlinkSync(filePath);
this.groupMetaMap.delete(groupId);
}
}

const cacheService = new CacheService();
module.exports = { cacheService };